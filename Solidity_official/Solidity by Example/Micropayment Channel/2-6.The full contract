pragma solidity >=0.4.24 <0.6.0;

contract SimplePaymentChannel {

//***ステータス

	address payable public sender;      // 支払いを送信するアカウント
	address payable public recipient;   // 支払いを受けている口座
	uint256 public expiration;  // 受信者が閉じない場合のタイムアウト

//***コンストラクタ
	//@pram	address型_recipient（ether受取可能）
	//@pram	uint256型duration（期間）
	//ether受取可能

	constructor (address payable _recipient, uint256 duration)
	public
	payable
	{
		sender = msg.sender;
			//変数senderにコンストラクタの実行者=このコントラクトの最初の実行者（送金者）を設定
			
		recipient = _recipient;	//引数_recipientを変数recipientに設定
		expiration = now + duration;	//タイムアウト時間を、現在時刻からduration時間後に設定
	}


//***function
	//@pram	uint256型amount
	//@pram	bytes型signature（保存先：memory）
	//return	bool型
	//コントラクト内のみ呼び出し可
	//読み取り専用


	function isValidSignature(uint256 amount, bytes memory signature)
	internal
	view
	returns (bool)
	{
		//後述のprefixed関数で
		//・このコントラクトのアドレス
		//・送金額
		//をハッシュ化し、bytes32型変数messageに格納
		
		bytes32 message = prefixed(keccak256(abi.encodePacked(this, amount)));

		// 振込み人のサインであることを確認する
		
		return recoverSigner(message, signature) == sender;
			//・message
			//・引数signature
			//をrecoverSigner関数にかけて署名主のアドレスを復元
			//復元したアドレスがsenderと一致するかtrue/falseを返す
	}

//***署名者確認function

	/// 送信者から署名された金額を提示することで、
	/// 受信者はいつでもチャンネルを閉鎖可能

	function close(uint256 amount, bytes memory signature) public {
		require(msg.sender == recipient);
		require(isValidSignature(amount, signature));

		recipient.transfer(amount);
		selfdestruct(sender);
	}

//***function

	/// 差出人は有効期限をいつでも延長可能
	function extend(uint256 newExpiration) public {
		require(msg.sender == sender);
		require(newExpiration > expiration);

		expiration = newExpiration;
	}

//***function

	/// 受信者がチャネルを閉じることなくタイムアウトに達した場合、etherは送信者に戻される
	
	function claimTimeout() public {
		require(now >= expiration);
		selfdestruct(sender);
	}


//***function

	/// 以下の機能は、「署名の作成と検証」の章から抜粋

	function splitSignature(bytes memory sig)
	internal
	pure
	returns (uint8 v, bytes32 r, bytes32 s)
	{
		require(sig.length == 65);

		assembly {
			// rに長さのプレフィックスの後の、最初の32バイトを格納
			r := mload(add(sig, 32))
			
			// 次の32バイト
			s := mload(add(sig, 64))
			
			// 最後のバイト (次の32バイトの最初のバイト)
			v := byte(0, mload(add(sig, 96)))
		}

		return (v, r, s);
	}


//***function

	function recoverSigner(bytes32 message, bytes memory sig)
	internal
	pure
	returns (address)
	{
		(uint8 v, bytes32 r, bytes32 s) = splitSignature(sig);

		return ecrecover(message, v, r, s);
	}


//***function

	/// eth_signの動作を模倣した接頭辞付きハッシュを構築
	function prefixed(bytes32 hash) internal pure returns (bytes32) {
		return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
	}
	
	
}
