pragma solidity >=0.4.24 <0.6.0;

contract SimplePaymentChannel {

//***ステータス

	address payable public sender;      // The account sending payments.
	address payable public recipient;   // The account receiving the payments.
	uint256 public expiration;  // Timeout in case the recipient never closes.

//***コンストラクタ

	constructor (address payable _recipient, uint256 duration)
	public
	payable
	{
		sender = msg.sender;
		recipient = _recipient;
		expiration = now + duration;
	}


//***function

	function isValidSignature(uint256 amount, bytes memory signature)
	internal
	view
	returns (bool)
	{
		bytes32 message = prefixed(keccak256(abi.encodePacked(this, amount)));

		// 振込み人のサインであることを確認する
		return recoverSigner(message, signature) == sender;
	}

//***function

	/// 送信者から署名された金額を提示することで、
	/// 受信者はいつでもチャンネルを閉鎖可能

	function close(uint256 amount, bytes memory signature) public {
		require(msg.sender == recipient);
		require(isValidSignature(amount, signature));

		recipient.transfer(amount);
		selfdestruct(sender);
	}

//***function

	/// 差出人は有効期限をいつでも延長可能
	function extend(uint256 newExpiration) public {
		require(msg.sender == sender);
		require(newExpiration > expiration);

		expiration = newExpiration;
	}

//***function

	/// 受信者がチャネルを閉じることなくタイムアウトに達した場合、etherは送信者に戻される
	
	function claimTimeout() public {
		require(now >= expiration);
		selfdestruct(sender);
	}


//***function

	/// 以下の機能は、「署名の作成と検証」の章から抜粋

	function splitSignature(bytes memory sig)
	internal
	pure
	returns (uint8 v, bytes32 r, bytes32 s)
	{
		require(sig.length == 65);

		assembly {
			// rに長さのプレフィックスの後の、最初の32バイトを格納
			r := mload(add(sig, 32))
			
			// 次の32バイト
			s := mload(add(sig, 64))
			
			// 最後のバイト (次の32バイトの最初のバイト)
			v := byte(0, mload(add(sig, 96)))
		}

		return (v, r, s);
	}


//***function

	function recoverSigner(bytes32 message, bytes memory sig)
	internal
	pure
	returns (address)
	{
		(uint8 v, bytes32 r, bytes32 s) = splitSignature(sig);

		return ecrecover(message, v, r, s);
	}


//***function

	/// eth_signの動作を模倣した接頭辞付きハッシュを構築
	function prefixed(bytes32 hash) internal pure returns (bytes32) {
		return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
	}
	
	
}
