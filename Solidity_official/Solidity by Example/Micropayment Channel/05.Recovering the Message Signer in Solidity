【公式ページ】
一般的にECDSA署名は r と s という2つのパラメータで構成されています。Ethereum上の署名は3つ目のパラメータ v を含んでいます。これは署名のどのアカウントの秘密鍵が使われたか、トランザクションの送信者が誰か検証するのに使われます。

Solidityは r、s そして v パラメータと一緒にメッセージを受け入れるビルトインファンクションの ecrecover を持っています。さらにこのファンクションはメッセージに署名したアドレスを返します。


⇒r, s, vって何？？？？


［結論］
・r は一時秘密鍵を用いて、あれこれして算出する値
・s はrやらなんやらをあれこれして算出する値
・v はセキュリティのために設定する値（一定の計算で算出）

・ecrecover機能
https://scrapbox.io/sushiether/Solidity_%E3%81%AE_ecrecover_%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%97%E3%81%A6%E7%BD%B2%E5%90%8D%E8%80%85%E3%81%AE%E3%82%A2%E3%83%89%E3%83%AC%E3%82%B9%E3%82%92%E5%8F%96%E5%BE%97%E3%81%99%E3%82%8B
（※）
→メッセージのハッシュ、v, r, s から署名者の公開鍵を得る
→その公開鍵から送付元のEthereum アドレスを算出する






以下メモ書き



【ECDA署名】
ECDSAとは
⇒Elliptic Curve Digital Signature Algorithm：楕円曲線デジタル署名アルゴリズム。楕円曲線を使った公開鍵暗号

https://zoom-blc.com/what-is-ecdsa
・ビットコインやイーサリアムの文脈では特にトランザクションの署名に使われる
	・他の第三者によって生成された偽データではない（署名者以外が偽造した署名ではない）
	・トランザクション生成後、第三者によってデータが改ざんされていないことが確認できる
	・生成者が生成したトランザクションであると誰もが証明できる
・署名生成と検証は秘密鍵とそれに対をなす公開鍵によって行われる
・これら(r, s, v)の値と送信者（署名者）の公開鍵を用いることで、トランザクションが正しく署名されていることを確認するための検証作業が行われる

https://www.etarou.work/posts/4968764/
・全てのノードは新規トランザクションを生成する際に、トランザクションデータのunlocking scriptの中に"自身の秘密鍵から生成したECDSAデジタル署名(r, sという2つの値)"を入れ込んで、Bitcoinネットワークに伝搬することでこれを解決する
→秘密鍵を持たない主体がトランザクションデータを改ざんした場合にはこの署名との辻褄が合わなくなる
→伝搬してきた新規トランザクションを受け取ったノードは、そのトランザクションデータが途中で改竄されていないかどうかを確認することが可能



【ECDSAによる署名生成】
楕円曲線のパラメータの上で
・位数n以下の乱数を発生させ、秘密鍵とする
・秘密鍵 * G の計算をする
・結果たどり着いた点を公開鍵とする

⇒今回トランザクションを生成するノード（署名者/送金者）の
pubKey=privKey* Gで生成される
・秘密鍵をprivKey
・対応する公開鍵をpubKey（ネットワークの誰もが持つことが可能）
を設定

例
1-1. 乱数を一時的な秘密鍵：TprivKey（T=Temporary）
     ※privKey≠Tprivkey
1-2. 処理がされる（URL参照）
1-3. TprivKeyから楕円曲線上の基準点をGを用いて楕円曲線secp256k1上の点　TprivKey * G = (x, y)を求める
→一時的な秘密鍵TprivKeyから一時的な公開鍵(x, y)を導く
1-4. r = x とする
⇒r = TprivKey * Gの x座標（公開鍵の一部）
☆楕円曲線で導く≒ハッシュ化作業が用いられる→r からTprivKeyの算出不可能

2-1. s　=　(TransactionHash+ priveKey * r)*(mod p)/TpriveKey
⇒☆よりrを踏まえて求めるsからTprivKeyを算出することは不可能

［結論①］
・r は一時秘密鍵をあれこれして算出する値
・s はrやらなんやらをあれこれして算出する値
・r の時点で一時秘密鍵をハッシュ化してるから、一時秘密鍵の逆算はrからもsからも不可能

【署名の検証】
・r とs を用いて値Qを求める
・計算した結果Q = TprivKey * Gとなれば検証成功
→Gの座標x がr


→「計算したQの x座標部分 が 伝搬されて来た r の値と同じ」なら
①このトランザクションにinputされているUTXO（未使用トランザクション）の所有者は間違いなくトランザクションの作成者である
→
②トランザクションデータの中身は途中で改竄されていない
→「Qを計算したノードに届いた時点のトランザクションのハッシュ＝s、つまりこのトランザクションデータが作成された時のトランザクションのハッシュ」が証明される



***
1-1	トランザクションデータ→送信者アドレス含まれず
→ECDSA署名から署名者＝送信者の公開鍵・アドレスが算出できてしまう
1-2	署名から公開鍵の復元
→2つ目の公開鍵の生成
→2点あれば楕円曲線を割出されてしまう

2	テストネットのETHをメインネットのETHで使えてしまう
→chain_id要素を加えて防止（リプレイアタック対策）
chain_id:https://qiita.com/hm0429/items/224d420364b36cf43e85


1,2を防止するため、公開鍵を一意に定め、chain_id要素を加えたい
→v値を設定

［結論②］
・v セキュリティのために設定する値（一定の計算で算出）
***

以上を踏まえて署名トランザクションには
nonce
gasPrice
gas limit
to
value
data
v, r, s←new!
を含ませる
